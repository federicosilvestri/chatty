\documentclass[]{article}
\usepackage[]{algorithm2e}
\usepackage{float}

%opening
\title{SOL - Progetto Chatty}
\author{Federico Silvestri 559014}

\begin{document}
\maketitle


\begin{abstract}
Questo documento contiene la documentazione relativa al progetto Chatty del modulo Laboratorio del corso A di Sistemi Operativi anno 2017/2018.
\end{abstract}
\tableofcontents
\pagebreak

\section{Architecture}
L'architettura utilizzata per lo sviluppo del progetto \`e basata sul modello \textbf{producer/consumer},
con l'aggiunta di un ulteriore componente \textbf{controller} con la responsabilit\`a di pilotare quest'ultimi.
Sia producer che consumer sono gestiti unicamente dal controller che offre un meccanismo per lo scambio delle informazioni
e ne assicura il sincronismo. Di seguito verranno descritte le funzionalit\`a pincipali di ogni singolo componente.

\subparagraph[Una breve descrizione del modello]{Il modello}
Prima di descrivere l'architettura componente per componente \`e necessario illustrare il modello base che viene seguito.
Tecnicamente parlando esso prevede l'implementazione dei seguenti metodi:

\begin{figure}[H]
	\begin{table}[H]
		\begin{tabular}{ll}			
			\textbf{name} & \textbf{description} \\
			component\_init() & lettura configurazione, allocazione memoria \\
			component\_start() & creazione del thread/thread pool \\
			component\_stop() & invio del segnale di stop al(la) thread/thread pool \\
			component\_destroy() & iberazione memoria, chiusura file descriptors \\
		\end{tabular}
	\end{table}
\end{figure}

Questi quattro metodi garantiscono la robustezza e la sicurezza in quanto ognuno di essi racchiude
tutte le operazioni necessarie affinch\`e la memoria sia allocata e liberata, i file descriptor
aperti e chiusi, i thread avviati e stoppati.

\paragraph{Producer}
Il producer generalmente \`e il componente che si occupa di produrre il lavoro da far eseguire al
consumer: in questo caso la produzione di lavoro \`e intesa come la ricezione di eventi sulle socket
aperte dai client.

Per fare un esempio: quando un client invia un messaggio di REGISTER\_OP, quest'ultimo provoca
l'attivazione del Producer che dovr\`a occuparsi di gestire tale richiesta in modo pi\`u
veloce e \textit{fair} possibile, anche se non dovr\`a essere lui stesso a doverla
processare.

Sintetizzando, le responsabilit\`a principali del Producer sono:
\begin{itemize}
	\item Creazione e binding della socket di ascolto
	\item Accettazione delle nuove connessioni
	\item Migrazione della richiesta al producer
\end{itemize}

Una volta che la richiesta \`e stata presa in carico dal consumer,
il producer non ha nessun altra responsabilit\`a su di essa.

\paragraph{Consumer}
Le richieste che vengono messe all'interno della coda di attesa, vengono
ricevute in modo sequenziale da una delle istanze del componente consumer
(in quanto multithread), che \`e l'endpoint del flusso di trasferimento della richiesta.

Il consumer si occupa dunque di processarla ed eventualmente di:
\begin{itemize}
	\item rimanere in attesa di un altro evento
	\item chiudere la connessione
	\item rilasciare la connessione al producer
\end{itemize}

\paragraph{Controller}
Siccome \textbf{P e C} non sono in grado di essere
autonomi, c'\`e bisogno di un ulteriore componente che coordina
le operazioni principali, ovvero che esegue al momento giusto
e nell'ordine giusto i metodi che sono stati descritti
nel modello base. In particolare i punti pi\`u critici sono lo startup e lo 
shutdown, in quanto viene gestita la memoria e controllata
la correttezza della configurazione passata al sistema.
 
Ipotiziamo per esempio che non venisse eseguito il metodo \textit{init()}.
Questo comporterebbe che la memoria non verrebbe allocata 
e dunque durante il runtime si genererebbe un errore, molto probabilmente
di segmentazione.

Altra ipotesi: se non venisse eseguito il metodo \textit{destroy},
la memoria utilizzata dai componenti non verrebbe deallocata,
generando di conseguenza i temuti \textit{memory leaks}, lo stesso discorso
vale anche per i file descriptor.
\\
\\
Le fasi di inizializzazione e distruzione non hanno un ordine ben preciso,
in generale tutti i componenti possono essere inizializzati o distrutti
anche concorrentemente. Ovviamente a differenza di queste le fasi
di avvio e stop devono essere eseguite secondo l'ordine prestabilito
dalle necessit\`a dei componenti.
In questo contesto il producer viene avviato prima del consumer, perch\`e
la gestione delle socket delle connessioni \`e affidata completamente al
producer ed \`e di fondamentale importanza per il consumer.

\paragraph{Implementazione del producer}
Il producer viene lanciato come un thread separato dal processo principale,
in modo da poterlo rendere indipendente da esso in termini di segnali e di interazione con l'utente.
Durante la fase di inizializzazione viene creata e bindata la socket sulla quale
arriveranno le richieste da parte dei client, controllando che non sia gi\`a stata
utilizzata da un altro processo in esecuzione.
Infatti un requisito fondamentale per l'avvio del producer \`e proprio quello appena descritto: la mutua esclusivit\`a sulla socket di ascolto.
Una volta controllate le condizioni sufficienti all'avvio, con il  metodo \textit{producer\_init()}, viene lanciato il thread producer,
che si occuper\`a di gestire le connessioni con il seguente algoritmo:

\begin{algorithm}[H] 
	\While{server\_status == RUNNING}{
		socksMutex.lock();
		init\_fds()\;
		socksMutex.unlock()\;
		select(read\_fds, write\_fds)\;
		socksMutex.lock()\;
		
		\eIf{newConn()}{
			manageNewConn()\;
		}{
			manageCurrentConns()\;
		}
		socksMutex.unlock()\;
	}
	\caption{The producer algorithm}
\end{algorithm}

La variabile \textit{socksMutex} fa riferimento al meccanismo di sincronizzazione
che viene utilizzato per la mutua esclusivit\`a dell'accesso al vettore delle socket.
Il vettore delle socket, chiamato \textit{sockets} all'interno del codice, contiene
$n$ interi ognuno dei quali rappresenta il filedescriptor di una specifica connessione.
Tale vettore viene messo sotto controllo da un mutex perch\`e il consumer stesso lo utilizza
per processare la richiesta dell'utente.
Una volta che una connessione \`e stata presa in carico da un consumer in esecuzione,
gli viene data la responsabilit\`a di tutti gli eventi relativi a quella socket, fino a
che non viene rilasciata dal consumer stesso.
Questo meccanismo viene implementato attraverso il vettore $socket_blocks$, che contiene
$n$ booleani, dove $n$ \`e il numero massimo di connessioni.


\paragraph{Implementazione del consumer}
A differenza del producer, il consumer invece pu\`o essere lanciato in modalit\`a multithread.
Infatti all'interno del file di configurazione il parametro \textit{ThreadsInPool} specifica
quanti thread dovranno essere creati per gestire tutte le richieste.
L'obiettivo del consumer \`e quello di occuparsi dell'evento che \`e ricevuto nella socket.
Per evento si intende:
\begin{itemize}
	\item la scrittura di un messaggio dal client
	\item la disponibilit\`a di spazio sul buffer
\end{itemize}
Nel caso in cui si parli di scrittura da parte del client, il consumer si occuper\`a di leggere
il messaggio ed eseguire tutte le procedure per completare la richiesta.
Nel in cui si parli di lettura il consumer invier√† i messaggi disponibili al client.
Tutte queste funzionalit\`a sono state implementate nelle libreria nominata \textit{worker}.

\section{Librerie esterne}
\subsection{RabbitMQ}
\subsection{SQLite}
\subsection{Libconfig}

\section{Struttura del codice}

\end{document}
